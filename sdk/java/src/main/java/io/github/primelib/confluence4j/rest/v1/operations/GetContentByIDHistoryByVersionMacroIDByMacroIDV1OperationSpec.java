// WARNING: This file was generated by PrimeCodeGen. DO NOT EDIT.

package io.github.primelib.confluence4j.rest.v1.operations;

import java.util.Objects;
import java.util.function.Consumer;
import javax.annotation.processing.Generated;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.Accessors;
import org.jetbrains.annotations.ApiStatus;
import org.jspecify.annotations.NonNull;

/**
 * GetContentByIDHistoryByVersionMacroIDByMacroIDV1
 * <p>
 * Returns the body of a macro in storage format, for the given macro ID.
 * This includes information like the name of the macro, the body of the macro,
 * and any macro parameters. This method is mainly used by Cloud apps.
 * 
 * About the macro ID: When a macro is created in a new version of content,
 * Confluence will generate a random ID for it, unless an ID is specified
 * (by an app). The macro ID will look similar to this: '50884bd9-0cb8-41d5-98be-f80943c14f96'.
 * The ID is then persisted as new versions of content are created, and is
 * only modified by Confluence if there are conflicting IDs.
 * 
 * For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
 * This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
 * on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
 * 
 * Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
 * 
 * Example:
 * &lt;ac:adf-node type="extension"&gt;
 *   &lt;ac:adf-attribute key="extension-type"&gt;com.atlassian.ecosystem&lt;/ac:adf-attribute&gt;
 *   &lt;ac:adf-attribute key="parameters"&gt;
 *       &lt;ac:adf-parameter key="local-id"&gt;e9c4aa10-73fa-417c-888d-48c719ae4165&lt;/ac:adf-parameter&gt;
 *   &lt;/ac:adf-parameter&gt;
 * &lt;/ac:adf-node&gt;
 * 
 * Note, to preserve backwards compatibility this resource will also match on
 * the hash of the macro body, even if a macro ID is found. This check will
 * eventually become redundant, as macro IDs are generated for pages and
 * transparently propagate out to all instances.
 * 
 * This backwards compatibility logic does not apply to Forge macros; those
 * can only be retrieved by their ID.
 * 
 * **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
 * Permission to view the content that the macro is in.
 *
 */
@Getter
@Setter
@EqualsAndHashCode
@ToString
@Accessors(fluent = true, chain = true)
@Generated(value = "io.github.primelib.primecodegen")
public class GetContentByIDHistoryByVersionMacroIDByMacroIDV1OperationSpec {
    /**
     * allows to disable validation of the spec, use with care!
     */
    @ApiStatus.Experimental
    public static Boolean VALIDATION_ENABLED = true;

    /**
     * The ID for the content that contains the macro.
     *
     */
    @NonNull
    private String id;

    /**
     * The version of the content that contains the macro. Specifying `0` as the `version` will return
     * the macro body for the latest content version.
     *
     */
    @NonNull
    private Integer version;

    /**
     * The ID of the macro. This is usually passed by the app that the
     * macro is in. Otherwise, find the macro ID by querying the desired
     * content and version, then expanding the body in storage format.
     * For example, '/content/196611/version/7?expand=content.body.storage'.
     *
     */
    @NonNull
    private String macroId;

    /**
     * Constructs a validated instance of {@link GetContentByIDHistoryByVersionMacroIDByMacroIDV1OperationSpec}.
     *
     * @param spec the specification to process
     */
    @ApiStatus.Internal
    public GetContentByIDHistoryByVersionMacroIDByMacroIDV1OperationSpec(Consumer<GetContentByIDHistoryByVersionMacroIDByMacroIDV1OperationSpec> spec) {
        spec.accept(this);
        if (VALIDATION_ENABLED)
            validate();
    }

    /**
     * Validates the Spec, will throw a exception if required parameters are missing
     *
     * @throws NullPointerException
     */
    public void validate() {
        Objects.requireNonNull(id, "id is a required parameter!");
        Objects.requireNonNull(version, "version is a required parameter!");
        Objects.requireNonNull(macroId, "macroId is a required parameter!");
    }
}
