// WARNING: This file was generated by PrimeCodeGen. DO NOT EDIT.

package io.github.primelib.confluence4j.rest.v1.client;

import feign.Headers;
import feign.Param;
import feign.RequestLine;
import io.github.primelib.confluence4j.rest.v1.models.AsyncId;
import io.github.primelib.confluence4j.rest.v1.models.ContentBody;
import io.github.primelib.confluence4j.rest.v1.models.MacroInstance;
import java.util.List;
import javax.annotation.processing.Generated;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * ConfluenceRestClientContentMacroBodyApi
 */
@Generated(value = "io.github.primelib.primecodegen")
public interface ConfluenceRestClientContentMacroBodyApi {

    /**
    * GetContentByIDHistoryByVersionMacroIDByMacroIDV1
    * Get macro body by macro ID
    * Returns the body of a macro in storage format, for the given macro ID.
    * This includes information like the name of the macro, the body of the macro,
    * and any macro parameters. This method is mainly used by Cloud apps.
    * 
    * About the macro ID: When a macro is created in a new version of content,
    * Confluence will generate a random ID for it, unless an ID is specified
    * (by an app). The macro ID will look similar to this: '50884bd9-0cb8-41d5-98be-f80943c14f96'.
    * The ID is then persisted as new versions of content are created, and is
    * only modified by Confluence if there are conflicting IDs.
    * 
    * For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
    * This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
    * on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
    * 
    * Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
    * 
    * Example:
    * &lt;ac:adf-node type="extension"&gt;
    *   &lt;ac:adf-attribute key="extension-type"&gt;com.atlassian.ecosystem&lt;/ac:adf-attribute&gt;
    *   &lt;ac:adf-attribute key="parameters"&gt;
    *       &lt;ac:adf-parameter key="local-id"&gt;e9c4aa10-73fa-417c-888d-48c719ae4165&lt;/ac:adf-parameter&gt;
    *   &lt;/ac:adf-parameter&gt;
    * &lt;/ac:adf-node&gt;
    * 
    * Note, to preserve backwards compatibility this resource will also match on
    * the hash of the macro body, even if a macro ID is found. This check will
    * eventually become redundant, as macro IDs are generated for pages and
    * transparently propagate out to all instances.
    * 
    * This backwards compatibility logic does not apply to Forge macros; those
    * can only be retrieved by their ID.
    * 
    * **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
    * Permission to view the content that the macro is in.
    *
    * @param id The ID for the content that contains the macro.
    * @param version The version of the content that contains the macro. Specifying `0` as the `version` will return
    * the macro body for the latest content version.
    * @param macroId The ID of the macro. This is usually passed by the app that the
    * macro is in. Otherwise, find the macro ID by querying the desired
    * content and version, then expanding the body in storage format.
    * For example, '/content/196611/version/7?expand=content.body.storage'.
    */
    @RequestLine("GET /wiki/rest/api/content/{id}/history/{version}/macro/id/{macroId}")
    @Headers({
        "Accept: application/json"
    })
    MacroInstance GetContentByIDHistoryByVersionMacroIDByMacroIDV1(
            @NotNull @Param("id") String id,
            @NotNull @Param("version") Integer version,
            @NotNull @Param("macroId") String macroId
    );

    /**
    * GetContentByIDHistoryByVersionMacroIDByMacroIDConvertByToV1
    * Get macro body by macro ID and convert the representation synchronously
    * Returns the body of a macro in format specified in path, for the given macro ID.
    * This includes information like the name of the macro, the body of the macro,
    * and any macro parameters.
    * 
    * About the macro ID: When a macro is created in a new version of content,
    * Confluence will generate a random ID for it, unless an ID is specified
    * (by an app). The macro ID will look similar to this: '50884bd9-0cb8-41d5-98be-f80943c14f96'.
    * The ID is then persisted as new versions of content are created, and is
    * only modified by Confluence if there are conflicting IDs.
    * 
    * For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
    * This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
    * on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
    * 
    * Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
    * 
    * Example:
    * &lt;ac:adf-node type="extension"&gt;
    *   &lt;ac:adf-attribute key="extension-type"&gt;com.atlassian.ecosystem&lt;/ac:adf-attribute&gt;
    *   &lt;ac:adf-attribute key="parameters"&gt;
    *       &lt;ac:adf-parameter key="local-id"&gt;e9c4aa10-73fa-417c-888d-48c719ae4165&lt;/ac:adf-parameter&gt;
    *   &lt;/ac:adf-parameter&gt;
    * &lt;/ac:adf-node&gt;
    * 
    * Note, to preserve backwards compatibility this resource will also match on
    * the hash of the macro body, even if a macro ID is found. This check will
    * eventually become redundant, as macro IDs are generated for pages and
    * transparently propagate out to all instances.
    * 
    * This backwards compatibility logic does not apply to Forge macros; those
    * can only be retrieved by their ID.
    * 
    * **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
    * Permission to view the content that the macro is in.
    *
    * @param id The ID for the content that contains the macro.
    * @param version The version of the content that contains the macro. Specifying `0` as the `version` will return
    * the macro body for the latest content version.
    * @param macroId The ID of the macro. This is usually passed by the app that the
    * macro is in. Otherwise, find the macro ID by querying the desired
    * content and version, then expanding the body in storage format.
    * For example, '/content/196611/version/7?expand=content.body.storage'.
    * @param to The content representation to return the macro in.
    * @param expand A multi-value parameter indicating which properties of the content to expand and populate. Expands are dependent on the
    * `to` conversion format and may be irrelevant for certain conversions (e.g. `macroRenderedOutput` is redundant when
    * converting to `view` format). 
    * 
    * If rendering to `view` format, and the body content being converted includes arbitrary nested content (such as macros); then it is 
    * necessary to include webresource expands in the request. Webresources for content body are the batched JS and CSS dependencies for
    * any nested dynamic content (i.e. macros).
    * 
    * - `embeddedContent` returns metadata for nested content (e.g. page included using page include macro)
    * - `mediaToken` returns JWT token for retrieving attachment data from Media API
    * - `macroRenderedOutput` additionally converts body to view format
    * - `webresource.superbatch.uris.js` returns all common JS dependencies as static URLs
    * - `webresource.superbatch.uris.css` returns all common CSS dependencies as static URLs
    * - `webresource.superbatch.uris.all` returns all common dependencies as static URLs
    * - `webresource.superbatch.tags.all` returns all common JS dependencies as html `&lt;script&gt;` tags
    * - `webresource.superbatch.tags.css` returns all common CSS dependencies as html `&lt;style&gt;` tags
    * - `webresource.superbatch.tags.js` returns all common dependencies as html `&lt;script&gt;` and `&lt;style&gt;` tags
    * - `webresource.uris.js` returns JS dependencies specific to conversion
    * - `webresource.uris.css` returns CSS dependencies specific to conversion
    * - `webresource.uris.all` returns all dependencies specific to conversion     
    * - `webresource.tags.all` returns common JS dependencies as html `&lt;script&gt;` tags
    * - `webresource.tags.css` returns common CSS dependencies as html `&lt;style&gt;` tags
    * - `webresource.tags.js` returns common dependencies as html `&lt;script&gt;` and `&lt;style&gt;` tags
    * @param spaceKeyContext The space key used for resolving embedded content (page includes,
    * files, and links) in the content body. For example, if the source content
    * contains the link `&lt;ac:link&gt;&lt;ri:page ri:content-title="Example page" /&gt;&lt;ac:link&gt;`
    * and the `spaceKeyContext=TEST` parameter is provided, then the link
    * will be converted to a link to the "Example page" page in the "TEST" space.
    * @param embeddedContentRender Mode used for rendering embedded content, like attachments.
    * 
    * - `current` renders the embedded content using the latest version.
    * - `version-at-save` renders the embedded content using the version at
    * the time of save.
    */
    @RequestLine("GET /wiki/rest/api/content/{id}/history/{version}/macro/id/{macroId}/convert/{to}?expand={expand}&spaceKeyContext={spaceKeyContext}&embeddedContentRender={embeddedContentRender}")
    @Headers({
        "Accept: application/json"
    })
    ContentBody GetContentByIDHistoryByVersionMacroIDByMacroIDConvertByToV1(
            @NotNull @Param("id") String id,
            @NotNull @Param("version") Integer version,
            @NotNull @Param("macroId") String macroId,
            @NotNull @Param("to") String to,
            @Nullable @Param("expand") List<String> expand,
            @Nullable @Param("spaceKeyContext") String spaceKeyContext,
            @Nullable @Param("embeddedContentRender") String embeddedContentRender
    );

    /**
    * GetContentByIDHistoryByVersionMacroIDByMacroIDConvertAsyncByToV1
    * Get macro body by macro ID and convert representation Asynchronously
    * Returns Async Id of the conversion task which will convert the macro into a content body of the desired format.
    * The result will be available for 5 minutes after completion of the conversion.
    * 
    * About the macro ID: When a macro is created in a new version of content,
    * Confluence will generate a random ID for it, unless an ID is specified
    * (by an app). The macro ID will look similar to this: '884bd9-0cb8-41d5-98be-f80943c14f96'.
    * The ID is then persisted as new versions of content are created, and is
    * only modified by Confluence if there are conflicting IDs.
    * 
    * For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
    * This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
    * on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
    * 
    * Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
    * 
    * Example:
    * &lt;ac:adf-node type="extension"&gt;
    *   &lt;ac:adf-attribute key="extension-type"&gt;com.atlassian.ecosystem&lt;/ac:adf-attribute&gt;
    *   &lt;ac:adf-attribute key="parameters"&gt;
    *       &lt;ac:adf-parameter key="local-id"&gt;e9c4aa10-73fa-417c-888d-48c719ae4165&lt;/ac:adf-parameter&gt;
    *   &lt;/ac:adf-parameter&gt;
    * &lt;/ac:adf-node&gt;
    * 
    * Note, to preserve backwards compatibility this resource will also match on
    * the hash of the macro body, even if a macro ID is found. This check will
    * eventually become redundant, as macro IDs are generated for pages and
    * transparently propagate out to all instances.
    * 
    * This backwards compatibility logic does not apply to Forge macros; those
    * can only be retrieved by their ID.
    * 
    * **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
    * Permission to view the content that the macro is in.
    *
    * @param id The ID for the content that contains the macro.
    * @param version The version of the content that contains the macro. Specifying `0` as the `version` will return
    * the macro body for the latest content version.
    * @param macroId The ID of the macro. For apps, this is passed to the macro by the Connect/Forge framework.
    * Otherwise, find the macro ID by querying the desired
    * content and version, then expanding the body in storage format.
    * For example, '/content/196611/version/7?expand=content.body.storage'.
    * @param to The content representation to return the macro in.
    * Currently, the following conversions are allowed:
    * 
    * - `export_view`
    * - `styled_view`
    * - `view`
    * @param expand A multi-value parameter indicating which properties of the content to expand and populate. Expands are dependent on the
    * `to` conversion format and may be irrelevant for certain conversions (e.g. `macroRenderedOutput` is redundant when
    * converting to `view` format). 
    * 
    * If rendering to `view` format, and the body content being converted includes arbitrary nested content (such as macros); then it is 
    * necessary to include webresource expands in the request. Webresources for content body are the batched JS and CSS dependencies for
    * any nested dynamic content (i.e. macros).
    * 
    * - `embeddedContent` returns metadata for nested content (e.g. page included using page include macro)
    * - `mediaToken` returns JWT token for retrieving attachment data from Media API
    * - `macroRenderedOutput` additionally converts body to view format
    * - `webresource.superbatch.uris.js` returns all common JS dependencies as static URLs
    * - `webresource.superbatch.uris.css` returns all common CSS dependencies as static URLs
    * - `webresource.superbatch.uris.all` returns all common dependencies as static URLs
    * - `webresource.superbatch.tags.all` returns all common JS dependencies as html `&lt;script&gt;` tags
    * - `webresource.superbatch.tags.css` returns all common CSS dependencies as html `&lt;style&gt;` tags
    * - `webresource.superbatch.tags.js` returns all common dependencies as html `&lt;script&gt;` and `&lt;style&gt;` tags
    * - `webresource.uris.js` returns JS dependencies specific to conversion
    * - `webresource.uris.css` returns CSS dependencies specific to conversion
    * - `webresource.uris.all` returns all dependencies specific to conversion     
    * - `webresource.tags.all` returns common JS dependencies as html `&lt;script&gt;` tags
    * - `webresource.tags.css` returns common CSS dependencies as html `&lt;style&gt;` tags
    * - `webresource.tags.js` returns common dependencies as html `&lt;script&gt;` and `&lt;style&gt;` tags
    * @param allowCache If this field is false, the cache will erase its current value and begin a conversion.
    * If this field is true, the cache will not erase its current value, and will set the status of the
    * result in cache to RERUNNING. Once the data is updated, the status will change to COMPLETED. 
    * Large macros that take long to convert, and who want to show intermediate, but potentially stale data, immediately should set this field to true.
    * Cache values are stored per macro per user per content and expansions.
    * @param spaceKeyContext The space key used for resolving embedded content (page includes,
    * files, and links) in the content body. For example, if the source content
    * contains the link `&lt;ac:link&gt;&lt;ri:page ri:content-title="Example page" /&gt;&lt;ac:link&gt;`
    * and the `spaceKeyContext=TEST` parameter is provided, then the link
    * will be converted to a link to the "Example page" page in the "TEST" space.
    * @param embeddedContentRender Mode used for rendering embedded content, like attachments.
    * 
    * - `current` renders the embedded content using the latest version.
    * - `version-at-save` renders the embedded content using the version at
    * the time of save.
    */
    @RequestLine("GET /wiki/rest/api/content/{id}/history/{version}/macro/id/{macroId}/convert/async/{to}?expand={expand}&allowCache={allowCache}&spaceKeyContext={spaceKeyContext}&embeddedContentRender={embeddedContentRender}")
    @Headers({
        "Accept: application/json"
    })
    AsyncId GetContentByIDHistoryByVersionMacroIDByMacroIDConvertAsyncByToV1(
            @NotNull @Param("id") String id,
            @NotNull @Param("version") Integer version,
            @NotNull @Param("macroId") String macroId,
            @NotNull @Param("to") String to,
            @Nullable @Param("expand") List<String> expand,
            @Nullable @Param("allowCache") Boolean allowCache,
            @Nullable @Param("spaceKeyContext") String spaceKeyContext,
            @Nullable @Param("embeddedContentRender") String embeddedContentRender
    );

}
